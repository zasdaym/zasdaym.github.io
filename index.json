[{"content":"Nowadays many configurations are done via YAML format. GitLab CI, GitHub Actions, Hugo, Docker compose, and of course Kubernetes. A YAML processor like yq will be useful when working with tools like kubectl that can output YAML.\nBasic features For examples in basic features section, we use a file deployment.yaml with the following content:\napiVersion: v1 kind: Deployment metadata: name: hello-world spec: template: spec: containers: - name: hello image: hello:v0.0.1 - name: world image: world:v0.0.2 Get specific field To get only the .metadata.name field, use:\nyq e \u0026#39;.metadata.name\u0026#39; deployment.yaml Loop over array Let\u0026rsquo;s get all images:\nyq e \u0026#39;.spec.template.spec.containers[].image\u0026#39; deployment.yaml Delete field To delete the first container, use:\nyq e \u0026#39;del(.spec.template.spec.containers[0])\u0026#39; deployment.yaml Update field Update the second container name to new-world:\nyq e \u0026#39;.spec.containers[1].name = \u0026#34;new-world\u0026#34;\u0026#39; deployment.yaml Specific kubectl example Here\u0026rsquo;s some example of using kubectl with yq.\nGet Service names where the type is NodePort kubectl get svc -o yaml | yq e \u0026#39;.items[] | select(.spec.type == \u0026#34;NodePort\u0026#34;)\u0026#39; - Get Deployments with some fields removed kubectl get deployment -o yaml | yq e \u0026#39; .items[] | del(.metadata.annotations) | del(.metadata.creationTimestamp) | del(.metadata.generation) | del(.metadata.resourceVersion) | del(.metadata.selfLink) | del(.metadata.uid) | del(.status) | splitDoc\u0026#39; - Reference To learn more about yq, just check the official documentation at https://mikefarah.gitbook.io/yq/\n","permalink":"https://zasdaym.github.io/posts/yq/","summary":"Nowadays many configurations are done via YAML format. GitLab CI, GitHub Actions, Hugo, Docker compose, and of course Kubernetes. A YAML processor like yq will be useful when working with tools like kubectl that can output YAML.\nBasic features For examples in basic features section, we use a file deployment.yaml with the following content:\napiVersion: v1 kind: Deployment metadata: name: hello-world spec: template: spec: containers: - name: hello image: hello:v0.0.1 - name: world image: world:v0.","title":"YAML processing with yq"},{"content":"For some small tasks, sometimes Bash script (shell script in general) is better than a full-blown program using programming languages. Here are some personal tips to write a Bash script:\nExit on fail Use set -o errexit to make the script exit when it fails. If some commands are allowed to fail, command1 || echo \u0026quot;command1 is failed, but continuing\u0026quot; can be used.\nPrevent access to undeclared variables Use set -o nounset to exit when the script tries to use undeclared variables. Imagine running this command when undeclared variables is allowed:\nrm -rf ${base_folder}/* When the variable $base_folder is not set, it will become rm -rf /*. If some variables are allowed to be undeclared, use ${variable_name:default_value} to set $variable_name to default_value when it\u0026rsquo;s not declared.\nIdempotency What is idempotency?\nIdempotence is the property of certain operations in mathematics and computer science whereby they can be applied multiple times without changing the result beyond the initial application.\nIn short, it means that idempotent Bash scripts should have the same effects on the system even when called multiple times. Some example of idempotency in Bash script:\nCreating a symbolic link The basic syntax of creating a symbolic link is:\nln -s source target This is not idempotent, it will fail in the second run because the target is already exists. It can be solved by adding the -f flag:\nln -sf source target If executed multiple times, it\u0026rsquo;s still not idempotent because it will create a symbolic link inside the previously created symbolic link (nested). The idempotent way to create a symbolic link is:\nln -sfn source target Removing a file The command rm filename will fail if the file does not exist. Use rm -f instead. To remove directory, use rm -rf instead.\nDownloading a file Common usage is to download a file if only it does not exist:\nif [[ ! -f ${HOME}/.local/bin/random_binary ]]; then wget -qO ${HOME}/.local/bin/random_binary https://randomsite.com/random_binary fi Use curly brace when using variable inside a string When using variables inside a string, sometimes it\u0026rsquo;s clearer to access the variable with the curly brace. So instead of this:\necho \u0026#34;$var1_new.yaml\u0026#34; Prefer this:\necho \u0026#34;${var1}_new.yaml\u0026#34; So it\u0026rsquo;s clear that the variable name is var1, not var1_new.\n","permalink":"https://zasdaym.github.io/posts/bash-script/","summary":"For some small tasks, sometimes Bash script (shell script in general) is better than a full-blown program using programming languages. Here are some personal tips to write a Bash script:\nExit on fail Use set -o errexit to make the script exit when it fails. If some commands are allowed to fail, command1 || echo \u0026quot;command1 is failed, but continuing\u0026quot; can be used.\nPrevent access to undeclared variables Use set -o nounset to exit when the script tries to use undeclared variables.","title":"Bash script tips"},{"content":"Γειά σου Κόσμε!\n","permalink":"https://zasdaym.github.io/posts/hello-world/","summary":"Γειά σου Κόσμε!","title":"Γειά σου Κόσμε!"}]